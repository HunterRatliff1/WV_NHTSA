---
title: "Exploratory Data Analysis"
author: "Hunter Ratliff"
date: "`r Sys.Date()`"
params:
  remote:
    label: "Use remote data?"
    value: FALSE
output: 
  bookdown::html_document2: 
    toc: yes
    toc_float: true
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=F, message=F)

library(tidyverse)
library(here)
library(lubridate)
library(cowplot) # For multiple plots, also use gridExtra
library(ggpp) # Plotting tables on ggplots
# ggpmisc, ggpp


# For missing data
library(skimr)
library(naniar)

# For diagrams
library(DiagrammeR)

# For maps
library(sf)
library(mapview)
library(mapboxapi)
library(mapview)
library(tmap)

library(tigris)
options(tigris_class = "sf")
options(tigris_use_cache = TRUE)

comment_header <- function(txt, width=80){
  padding <- (width - str_length(txt))/2
  padding <- floor(padding) - 5
  
  str_glue('####{str_dup("-",padding)} {txt} {str_dup("-",padding)}####')
  
}
```

# Read in data

The cleaned CSV's can be downloaded via [GitHub](https://github.com/HunterRatliff1/WV_NHTSA/tree/main/NHTSA_CSV). For downloading the actual data via the API, see [Get_NHTSA_JSON.Rmd](https://github.com/HunterRatliff1/WV_NHTSA/blob/main/Get_NHTSA_JSON.Rmd).

```{r read-csv}
if(!params$remote){
  df_cases           <- readr::read_csv(here("NHTSA_CSV", "cases.csv"), 
                                        col_types = "nnTddffdlffcfcnnnn")
  df_vehicles        <- readr::read_csv(here("NHTSA_CSV", "vehicles.csv"), 
                                        col_types = "nnnnnnlclldfcnfff") 
  df_violations_long <- readr::read_csv(here("NHTSA_CSV", "violations.csv"), 
                                        col_types = "ddddfd")
  df_persons         <- readr::read_csv(here("NHTSA_CSV", "persons.csv"), 
                                        col_types = "ddddddfffflfcfllfldf")
}
if(params$remote){
  prefix <- "https://github.com/HunterRatliff1/WV_NHTSA/raw/main/NHTSA_CSV/"
  
  df_cases           <- read_csv(paste0(prefix, "cases.csv"), 
                                 col_types = "nnTddffdlffcfcnnnn")
  df_vehicles        <- read_csv(paste0(prefix, "vehicles.csv"),
                                 col_types = "nnnnnnlclldfcnfff")
  df_violations_long <- read_csv(paste0(prefix, "violations.csv"),
                                 col_types = "ddddfd")
  df_persons         <- read_csv(paste0(prefix, "persons.csv"),
                                 col_types = "ddddddfffflfcfllfldf")
  
  rm(prefix)
} 
```

## Minor changes

We'll make a few adjustments by explicitly coding data as NA.

```{r}
# df_cases %>% skim() %>% dplyr::filter(n_missing > 0)

df_vehicles <- df_vehicles %>%
  mutate(DISTRACT = na_if(DISTRACT, "Not Reported"),
         DISTRACT = na_if(DISTRACT, "Unknown if Distracted"),
         DISTRACT = na_if(DISTRACT, "Reported as Unknown if Distracted"),
         IMPAIR   = na_if(IMPAIR, "Unknown"))
```

Additionally, because we only have have a PER_TYP of "Driver" or "Passenger" in the **persons** file, we can make this a logical flag for `driver` to more easily filter

```{r}
df_persons <- df_persons %>% 
  mutate(driver = PER_TYP=="Driver") %>%
  relocate(driver, .before = PER_TYP) 

df_persons %>%
  count(PER_TYP, driver) %>%
  knitr::kable()
```

```{r}
# df_violations_long %>%
#   group_by(CaseYear, ST_CASE, VEH_NO) %>%
#   summarise(n = unique(n_violations))
```

# Missing data

Before we get going, let's explore the missing data. We'll do this for each of the three data.frames we'll be working with:

-   Cases
-   Vehicles
-   Persons

## Cases

```{r missing-cases, class.source = 'fold-show'}
#| fig.cap = c("*Cases missing data, overall*",
#|             "*Cases missing data, by sets of missingness*")
naniar::vis_miss(df_cases, sort_miss=T)
naniar::gg_miss_upset(df_cases)
```

For the **cases** data.frame (the one with one crash per line), the main source of missing data is the time that EMS arrived (`EMS_time`) and they were transported to the hospital (`Hosp_time`). Not surprisingly, there is a strong correlation between having a missing EMS arrival time and missing hospital arrival time (the leftmost, tallest bar in the second plot above)

## Vehicles

Each row in the **vehicles** data.frame is a vehicle, so the structure here is a little bit more hairy. Some variables in this table are clearly specific to the vehicle itself (e.g. *Make/model, body*), and it doesn't look like those have many issues with missing data (Figure \@ref(fig:missing-vehicles-1), below).

However, other factors (e.g. *impairment, distraction, driver zipcode*) are driver level factors, and some of these are heavily missing. While there are some driver level factors included in this table (*if they were drinking or speeding*), one key variable, [driver death]{.underline}, isn't recorded in this table.

This could be a major confounding factor when it comes to missing data, especially for impairment, distraction, or the driver's zipcode. After all, if the driver of a motorcycle crash died immediately on impact, it may be difficult to inquire if they had been impaired by emotion or distracted.

```{r missing-vehicles, class.source = 'fold-show'}
#| fig.cap = c("*Vehicles missing data, overall*",
#|             "*Vehicles missing data, by sets of missingness*")
vis_miss(df_vehicles, sort_miss=T)
gg_miss_upset(df_vehicles) 
```

This hypothesis that some of the missing data may be coming from the driver being unavailable for questioning is somewhat supported by Figure \@ref(fig:missing-vehicles-2) above. We see that in the cases where driver zip code (`DR_ZIP`) is missing, there is often other data that are missing as well.

To explore this in more detail, we will match each vehicle's record (green box below) to their respective driver in the **persons** data.frame (red box below) and pull out if the driver died.

```{r mermaid-diagram}
DiagrammeR::mermaid("
  graph TB
    subgraph cases table
        A1[Crash 1] 
        A2[Crash 2] 
    end
    
    subgraph vehicles table
        B1[Vehicle 1]
        B2[Vehicle 2] 
        B3[...] 
    end
    
    subgraph persons table
        C(Driver<br>Vehicle 1) 
        D(Passanger A<br>Vehicle 1) 
        E(Passanger B<br>Vehicle 1) 
        F(...) 
        G(...) 
    end
    
    A1 --> B1
    A1 -.-> B2
    A2 -.-> B3
    
    B1 ==> C
    B1 --> D 
    B1 --> E
    B2 -.-> F
    B3 -.-> G
    
    classDef driver fill:#ffcccb
    classDef grey fill: #d3d3d3
    classDef green fill: #73be73
    class B1 green
    class C driver
    class B3,F,G grey
")
```

So with all that said, let's finally look at how the missing data relates to other variables in the vehicles table. This can be thought of as the "bivariate analysis" for missing data.

In figure \@ref(fig:missing-vehicles-factors) below, the rates of missingness (fill color) is plotted for each variable in the the vehicles table (Y axis) by a stratification variable (X axis)

```{r missing-vehicles-factors, fig.dim=c(8,8)}
#| fig.cap = "*Vehicles missing data, by hit & run, driver death, and year 
#| of data collection*"
p1 <- df_vehicles %>%
  gg_miss_fct(fct=HIT_RUN) +
  theme(legend.position = "bottom") +
  labs(x="Hit & Run", y="")

p2 <- df_vehicles %>%
  # Join vehicles to the driver info
  left_join(filter(df_persons, driver) %>%
              select(CaseYear, ST_CASE, VEH_NO, NUMOCCS, died),
            by = join_by(CaseYear, ST_CASE, VEH_NO, NUMOCCS)) %>%
  filter(!is.na(died)) %>%
  
  gg_miss_fct(fct=died)  +
  theme(legend.position = "bottom") +
  labs(x="Driver died", y="")

p3 <- df_vehicles %>%
  gg_miss_fct(fct=CaseYear) +
  labs(x="Case year", y="")

title <- ggdraw() + 
  draw_label(
    "Missing data for vehicles, by (A) hit & run, (B) driver death, and (C) year",
    fontface = 'bold',
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

cowplot::plot_grid(
  title, 
  plot_grid(p1, p2, labels=c("A", "B")),
  plot_grid(p3, labels=c("C", "")),
  ncol=1,
  rel_heights = c(0.1, 1,.75)
)
rm(p1, p2, p3, title)
```

This reveals some interesting patterns. First, hit & runs (`HIT_RUN`) appear to account for a fair amount of the missing data that isn't impairment (`IMPAIR`) or distraction (`DSITRACT`). Second, driver death seems to account for a good portion (\~80%) of the missing impairment data.

Finally, the trends in distraction seems to change around 2018. Although the codes in the code book ([page 463](https://crashstats.nhtsa.dot.gov/Api/Public/ViewPublication/813417#page=468)) did change slightly around that time, there don't seem to be any new definitions introduced at that time. Because this seems strange, we can take a peek of the actual data pulled from FARS.

Figure \@ref(fig:distraction-missing-graph) shows the total distractions, including missing / unknown data, for each year. For simplicity, all *specified* distractions (e.g. texting) have been categorized as "distracted". Beginning it 2018, it appears that they became more explicit in recording "not distracted" vs "not reported". To be clear, there were *some* cases prior to 2018 where drivers were "not reported", but this really looks like they changed how they reported things.

```{r distraction-missing-graph}
#| fig.cap = "*Temporal trends in missing data for distractions, including missing data*"
tempdf <- paste0("https://github.com/HunterRatliff1/WV_NHTSA/raw/main/NHTSA_CSV/", 
       "vehicles.csv") %>%
  read_csv(col_types = "nnnnnnlclldfcnfff") %>%
  mutate(Distract = case_when(
    DISTRACT == "Not Distracted" ~ "Not distracted",
    DISTRACT == "Not Reported" ~ "Not Reported",
    DISTRACT == "Unknown if Distracted" ~ "Unknown",
    DISTRACT == "Unknown if Distracted" ~ "Reported as Unknown if Distracted",
    TRUE ~ "Distracted"
  )) %>% 
  count(CaseYear, Distract) 

p1 <- tempdf %>%
  ggplot(aes(x=CaseYear, y=n, color=Distract)) + 
  geom_line() + 
  theme_half_open() +
  labs(x="Year", y="Number of cases", title="Distractions by year")
  
  
p2 <- tempdf %>% 
    pivot_wider(names_from = Distract, values_from = n) %>%
    gridExtra::tableGrob(rows=NULL) 

gridExtra::grid.arrange(p1, p2, ncol=1)
rm(p1, p2, tempdf)
```

## Persons

Finally, we're onto the **persons** data.frame. In Figure \@ref(fig:missing-persons-1), the most common missing variables are `died_timing` (which is expected) and `BAC`. `AIR_BAG` and `EJECTION` are also missing in \>1% of cases, so we will explore those as well.

```{r missing-persons, class.source = 'fold-show'}
#| fig.cap = c("*Persons missing data, overall*",
#|             "*Persons missing data, by sets of missingness*")
naniar::vis_miss(df_persons, sort_miss=T)
naniar::gg_miss_upset(df_persons)
```

We can start by tackling the `EJECTION` data in Figure \@ref(fig:ejection-missing). When we stratify this by the vehicle type[^1], we quickly see that almost 95% of these cases are appropriately marked as N/A because they were driving a motorcycle / ATV / off road vehicle.

[^1]: This requires merging the persons data.frame with the vehicles data.frame

```{r ejection-missing, fig.cap="*Missing person data by vehicle*"}
temp.df <- df_persons %>%
    left_join(df_vehicles %>%
              select(CaseYear, ST_CASE, VEH_NO, Body),
            by = join_by(CaseYear, ST_CASE, VEH_NO)) %>%
  mutate(motor = case_when(
    Body=="Motorcycle" ~ "Motorcycle",
    Body=="ATV/Off road" ~ "ATV",
    # Body=="Unknown" ~ "Unknown",
    TRUE ~ "Other"
    )) 

x <- temp.df %>%
  group_by(motor) %>%
  miss_var_summary() %>%
  filter(variable %in% c("AIR_BAG", "EJECTION")) %>%
  mutate(pct_miss = round(pct_miss, 1)) %>%
  mutate(missing = str_glue("{n_miss} ({pct_miss}%)")) %>%
  select(-n_miss, -pct_miss) %>%
  pivot_wider(names_from = variable, values_from = missing) %>%
  rename(` `=motor)
  
temp.df %>%
  gg_miss_fct(fct=motor) +
  labs(x="Vehicle type", y="", 
       title="Missing data, by vehicle type",
       subtitle = "For 'persons' table") +
  annotate(geom = 'table',
           x=2,
           y=21,
           label=list(x)) 

rm(x, temp.df)
```

```{r, eval=F, echo=F}
# Look to see if they only recorded some airbags
df_persons %>%
    left_join(df_vehicles %>%
              select(CaseYear, ST_CASE, VEH_NO, Body, HIT_RUN),
            by = join_by(CaseYear, ST_CASE, VEH_NO)) %>%
  filter(!Body %in% c("Motorcycle", "ATV/Off road")) %>%
  mutate(motor = case_when(
    Body=="Motorcycle" ~ "Motorcycle",
    Body=="ATV/Off road" ~ "ATV",
    TRUE ~ "Other"
  )) %>%
  mutate(missing_airbag = is.na(AIR_BAG)) %>% 
  
  group_by(CaseYear, ST_CASE, VEH_NO, NUMOCCS) %>%
  summarise(missing = sum(missing_airbag)) %>%
  ungroup() %>%
  count(NUMOCCS, missing) %>%
  mutate(unequal = case_when(
    missing == 0       ~ "None missing",
    NUMOCCS == missing ~ "All",
    NUMOCCS != missing ~ "Some",
  )) %>%
  group_by(unequal) %>%
  summarise(n = sum(n))
```

We can also see that these vehicles account for a fair share of the missing `AIR_BAG` data, but a good proportion (\~10%) of the missing data are not motorcycles/ATVs (Figure \@ref(fig:ejection-missing)). Additionally, there appear to be a trend in temporality, similar to what we saw in the distractions data. Figure \@ref(fig:airbag-missing) shows this trend

```{r airbag-missing, fig.cap="*Temporal trends in airbag deployment*"}
temp.df <- df_persons %>%
  mutate(AIRBAG = case_when(
    is.na(AIR_BAG) ~ "Missing",
    AIR_BAG        ~ "Deployed",
    !AIR_BAG       ~ "Not Deployed"
  )) %>%
  count(CaseYear, AIRBAG) 

temp.df %>%
  ggplot(aes(x=CaseYear, y=n, color=AIRBAG)) + 
  geom_line() + 
  theme_half_open() +
    annotate(geom = 'table',
           x=2020.5,
           y=95,
           label=list(pivot_wider(temp.df, names_from = AIRBAG, values_from = n))) + 
  labs(x="Year", y="Number of cases", title="Airbag deployment by year")
  
rm(temp.df)
```

Lastly, we need to look into the variable that had the most missing data, `BAC`. Figure \@ref(fig:bac-missing) shows that passengers are more likely to have misisng BAC levels, but drivers still have a high proportion who don't have a BAC level recorded (\~50%).

```{r bac-missing, fig.cap="*Missing person data by person type*"}
df_persons %>%
  filter(!is.na(driver)) %>%
  gg_miss_fct(fct=PER_TYP) +
    labs(x="", y="", 
       title="Missing data, by person type",
       subtitle = "For 'persons' table") 

# df_persons %>%
#   filter(!is.na(driver)) %>%
#   group_by(PER_TYP) %>%
#   miss_var_summary() %>%
#     filter(variable=="BAC")
```

# Bivaraite stuff

```{r}
df_vehicles %>%
  select(CaseYear:HIT_RUN, Body, DISTRACT, IMPAIR, totalvehicles) %>%
  left_join(select(df_cases, CaseYear, ST_CASE, LONGITUD, LATITUDE, WEATHERNAME)) %>%
  st_as_sf(coords = c("LONGITUD", "LATITUDE"), crs=6602) %>%
  ggplot() +
  geom_sf(aes(color=DR_DRINK), alpha=.15)
  # summary()
  # View()
  # glimpse()


  
```

# Geography

```{r download-tigris}
library(sf)
library(mapview)
library(mapboxapi)
library(mapview)
library(tmap)

library(tigris)
options(tigris_class = "sf")
options(tigris_use_cache = TRUE)

# # Find the ideal CRS for this area
# crsuggest::suggest_crs(wv_counties)
WV_crs <- "NAD83" # 6602 works well too, but must read in FARS data using NAD83

# Download geography data
wv_counties <- tigris::counties(state = "WV", cb=T) %>%
  st_transform(crs = WV_crs)
wv_tract    <- tigris::tracts(state = "WV", cb=T) %>%
  st_transform(crs = WV_crs)
wv_cbg      <- tigris::block_groups(state = "WV", cb=T) %>%
  st_transform(crs = WV_crs)
wv_roads <- tigris::primary_secondary_roads("WV")

# # Background tiles for pretty mapping
# wv_cbg_tiles <- mapboxapi::get_static_tiles(
#   location = wv_counties,
#   zoom = 7,
#   style_id = "cll13kko400rd01p4chtqcbdi",
#   username = "hunterratliff1"
# )
```

## Get local hospitals

We can download the US Department of Homeland Security's [Homeland Infrastructure Foundation-Level Data (HIFLD)](https://hifld-geoplatform.hub.arcgis.com/) hospitals [data file](https://hifld-geoplatform.opendata.arcgis.com/datasets/75079bdea94743bcaca7b6e833692639/explore).

```{r download-hospital-locations}
# Hospital locations
hospital_url <- "https://services1.arcgis.com/Hp6G80Pky0om7QvQ/arcgis/rest/services/Hospital/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

hospitals <- st_read(hospital_url) %>%
  filter(STATUS=="OPEN", !TYPE %in% c("CHILDREN", "PSYCHIATRIC", "REHABILITATION", "LONG TERM CARE", "SPECIAL")) %>%
  select(ID, NAME, ADDRESS, CITY, STATE, ZIP, TYPE, NAICS_DESC, OWNER, BEDS, TRAUMA, HELIPAD) %>%
  st_transform(WV_crs) %>%
  distinct(ID, .keep_all = TRUE) %>%
  st_filter(st_transform(wv_counties, WV_crs),
            .predicate = st_is_within_distance,
            dist = 10000) #Within 10km of the border

rm(hospital_url)

# hospitals %>%
#   mapview()

# https://hifld-geoplatform.opendata.arcgis.com/maps/emergency-medical-service-ems-stations
# https://hifld-geoplatform.opendata.arcgis.com/maps/public-health-departments
# https://services1.arcgis.com/Hp6G80Pky0om7QvQ/arcgis/rest/services/Urgent_Care_Facilities/FeatureServer/0
# https://services1.arcgis.com/Hp6G80Pky0om7QvQ/arcgis/rest/services/Pharmacies/FeatureServer/0


```

```{r}
hospitals %>%
  mapview(zcol="TRAUMA")
```

## Distance calculations

In order to calculate the distances, we can either use `sf::st_distance()` to calculate the distance directly or `mapboxapi::mb_matrix()` to calculate the driving time. However, the MapBox API limits the "maximum number of coordinates" to 25 and the number of requests to 300 per minute (five per second).

This means that something like `mb_matrix(wv_counties, hospitals)` won't work, as this would be a `r nrow(wv_counties)` by `r nrow(hospitals)` matrix. In the past, I've gotten [around similar problems](https://www.hunterratliff1.com/post/geographical-distribution-of-neurosurgeons/#find-closest-provider-for-each-county) somewhat by just finding the closest point for each polygon, but this time we're using drive times which [can be more nuanced](https://walker-data.com/census-r/spatial-analysis-with-us-census-data.html#catchment-areas-with-buffers-and-isochrones).

To accomplish this task, we will need to to take a few different steps (and make some assumptions). First, we need to narrow down our [search space](https://dba.stackexchange.com/questions/274153/what-is-search-space-when-it-comes-to-query-optimization) to find more reasonable candidate solutions. After all, we don't need to compare every location (e.g. county, location of crash) to every single hospital; instead we could calculate the travel time to the nearest 5-15 hospitals (instead of all `r nrow(hospitals)`) and take it from there.

The function below takes a set of locations[^2] (`geo_polys`) and calculates the distance matrix to each of the provided points (`geo_points`). For each `geo_polys`, it then keeps the `n_closest` number of results and returns that in a tidy style data.frame

[^2]: These can be either polygons (e.g. counties, census tracts, census block groups) or points themselves (e.g. locations of crashes). In the event that polygons are provided, it uses the distance from the centroid

```{r, eval=F, include=F}
pt <- st_sfc(st_point(c(0,0)), st_point(c(0,3)), st_point(c(5,0))) 
print(pt)
plot(pt)
st_distance(pt, pt)
rm(pt)
```

```{r fxn1}
# mb_matrix(head(wv_counties), hospitals)
# mb_matrix(wv_counties, head(hospitals))

# get_dist <- function(county, sleep_time=0.2){
#   
#   Sys.sleep(sleep_time)
#   times <- mb_matrix(county, hospitals)
#   apply(times, 1, min)
# }


  
#   
# head(wv_counties) %>% 
#   mutate(x = geometry %>% map(function(x) x))
 

fxn1 <- function(geo_polys, geo_points, n_closest = 10,
                 name_polys="GEOID", name_points="ID"){
#' Get the distance matrix in a tidy format, and return the closest points
#'
#' @param geo_polys A sf object of either "MULTIPOLYGON" or "POINT" type. If
#'                  a polygon is used, distance is calculated by the centroid of
#'                  the polygon
#' @param geo_points A "POINT" sf object 
#' @param n_closest The number of items to return per geo_polys. For example
#'                  the default (10) returns the ten closest geo_points for each
#'                  geo_polys
#' @param name_polys The name of the column in geo_polys to use as names. 
#'                   Defaults to "GEOID"  
#' @param name_points The name of the column in geo_points to use as names. 
#'                    Defaults to "ID"  
#' @return Tidy dataframe
#' @examples
#' function(wv_counties, hospitals)
  
  
  ####--------------------------- Pre-processing ---------------------------####
  # Make the CRS match, using the poly geom
  # st_crs(geo_points) <- st_crs(geo_polys)
  
  # Get the type of geometries
  geo_polys_type  <- as.character(st_geometry_type(geo_polys)[[1]])
  geo_points_type <- as.character(st_geometry_type(geo_points)[[1]])
  
  # Test to see if centroids should be used (will be yes if not points)
  centroids <- geo_polys_type != "POINT"
  
  ####------------- Run some tests to check for correct inputs -------------####
    
  # inputs are sf objects
  testthat::expect_s3_class(geo_polys, "sf")
  testthat::expect_s3_class(geo_points, "sf")
  
  # Correct geometries
  testthat::expect_in(geo_polys_type, c("MULTIPOLYGON", "POINT"))
  testthat::expect_equal(geo_points_type, "POINT")
  
  # Same CRS
  testthat::expect_equal(st_crs(geo_polys)[[1]], st_crs(geo_points)[[1]])

  # Column names are in supplies data.frames
  testthat::expect_length(geo_polys[[name_polys]], nrow(geo_polys))
  testthat::expect_length(geo_points[[name_points]], nrow(geo_points))
    
  
  ####----------------------- Get the distance matrix ----------------------####
  # For each geo_polys to look up, calculate the distance to all of the 
  # geo_points. This returns a wide matrix with each row being a geo_poly
  # and column being a geo_point
  if(centroids){
    # Use the centroids
    dist <- geo_polys %>%
      st_centroid() %>%
      st_distance(geo_points)
  } 
  if(!centroids){
    dist <- geo_polys %>%
      st_distance(geo_points)
  }
  
  ####---------------------- Make it a tidy data.frame ----------------------####
  df <- dist %>%
    as.data.frame() %>%
    mutate(GEOID = geo_polys[[name_polys]]) %>%
    relocate(GEOID, .before=V1)
  
  # Rename the columns as supplied by `name_points`
  names(df) <- c(name_polys, geo_points[[name_points]])
  
  
  df %>%
    # Make long format, creating 3 columns: name_polys, name_points, and distance
    pivot_longer(cols      = -all_of(name_polys), 
                 names_to  = name_points,
                 values_to = "Distance") %>%
    
    # For each of the `geo_polys`, limit results to the `n_closest` `geo_points`
    slice_min(n        = n_closest,
              order_by = Distance,
              by       = name_polys)
}

# x <- fxn1(wv_tract, hospitals, n_closest = 5) 
```

```{r}
fxn1(wv_cbg, filter(hospitals, str_detect(TRAUMA, "LEVEL")), n_closest = 1) %>%
  # group_by(GEOID) %>%
  # filter(Distance==min(Distance)) %>%
  inner_join(wv_cbg, by = join_by(GEOID)) %>%
  mutate(Distance = as.numeric(Distance/1000)) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(aes(fill=Distance), color=NA) +
  geom_sf(data = df_cases %>%
            st_as_sf(coords = c("LONGITUD", "LATITUDE"), crs="NAD83"), 
          alpha=0.1) +
  geom_sf(data=filter(hospitals, str_detect(TRAUMA, "LEVEL")), color="red") +
  theme_void() +
  labs(title = "Distance to trauma center, by CBG",
       subtitle = "Black dots = fatal crashes; red dots = trauma centers",
       fill="Distance (km)",
       caption="Note: Distances are from centroid of census block group\nUS Census Bureau, US Dept Homeland Security, NHTSA")
```

```{r, eval=F}
# Conceptually, what we can do is shown below:
# Pick a number (n_closest) to find the closest number of hospitals to the area
# then find the distance to the farthest of these hospitals

fxn1(wv_tract, hospitals, n_closest = 5)  %>%
  # Find the distance from the fifth farthest hospital
  group_by(GEOID) %>%
  filter(Distance==max(Distance)) %>%
  
  # Join this distance to our data and make a circle around the centroid
  # of that geography
  inner_join(wv_tract, by = join_by(GEOID)) %>%
  mutate(geometry = st_centroid(geometry),
         geometry = st_buffer(geometry, dist=Distance)) %>%
  st_as_sf() %>%
  ggplot() + 
  geom_sf(color="red") +
  geom_sf(data=wv_tract, alpha=0.5) +
  geom_sf(data=hospitals, alpha=0.5)
```

```{r, eval=F}
temp.df <- df_persons %>%
  left_join(select(df_cases, CaseYear, ST_CASE, LONGITUD, LATITUDE, WEATHERNAME)) %>%
  filter(str_detect(HOSPITAL, "EMS")) %>%
  st_as_sf(coords = c("LONGITUD", "LATITUDE"), crs=WV_crs)

wv_counties %>% 
  ggplot() +
  geom_sf() + 
  geom_sf(aes(color=HOSPITAL), alpha=.25, data=temp.df) +
  facet_wrap("HOSPITAL")

rm(temp.df)
```

```{r}
sessioninfo::session_info()
```
